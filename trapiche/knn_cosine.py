# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01.2_knn_cosine_figure.ipynb.

# %% auto 0
__all__ = ['TAG', 'DATA_DIR', 'TMP_DIR', 'vec_size', 'min_annots', 'k', 'min_projects_vote', 'dominance_thres', 'k2',
           'dominance_thres2', 'core_df_file', 'genus_plus_sp_vec_file', 'genus_vec_file', 'core_df', 'genus_vec',
           'genus_plus_sp_vec', 'BIOME_AMEND_ABUNDANCE', 'nodes_list', 'fuzzy_mat_file', 'fuzzy_mat_amend_file',
           'fuzzy_mat_amend', 'amended_core_df_file', 'amended_core_df_slim', 'k_nn', 'tails',
           'get_species_from_diamond_set', 'process_get_average_embedd_macro_average_by_genus', 'process_diamond',
           'process_krona', 'extract_taxo', 'calculate_mean_gr_vec', 'calculate_gr_macro_vec',
           'calculate_gr_plus_sp_vec', 'load_core_data', 'get_nodes_frquencies', 'weighted_jaccard', 'get_best_shot',
           'get_top_k', 'fuzzy_prediction', 'chunked_fuzzy_prediction', 'vectorise_run', 'predict_runs']

# %% ../nbs/01.2_knn_cosine_figure.ipynb 4
import glob
import os
import json
import re
import pandas as pd
import math
import numpy as np
from tqdm import tqdm
from ssfMiscUtilities.generic import *

from . import config

# %% ../nbs/01.2_knn_cosine_figure.ipynb 5
from .goldOntologyAmendments import gold_categories,biome_graph,biome_original_graph

# %% ../nbs/01.2_knn_cosine_figure.ipynb 7
TAG = 'knn_cosine'

# %% ../nbs/01.2_knn_cosine_figure.ipynb 8
DATA_DIR = f"{config.basedir}/data/{TAG}"

# %% ../nbs/01.2_knn_cosine_figure.ipynb 9
os.makedirs(DATA_DIR,exist_ok=True)

# %% ../nbs/01.2_knn_cosine_figure.ipynb 10
TMP_DIR = f"{DATA_DIR}/temp"

# %% ../nbs/01.2_knn_cosine_figure.ipynb 12
from . import taxonomyTree
from .baseData import analysis_df
from .baseData import load_taxonomy_sets
from .baseData import RESULTS_BASE_DIR

# %% ../nbs/01.2_knn_cosine_figure.ipynb 13
from .utils import cosine_similarity,jaccard_similarity,cosine_similarity_pairwise

# %% ../nbs/01.2_knn_cosine_figure.ipynb 16
from .biome2vec import taxo_ids
from .taxonomyTree import taxonomy_graph
from .biome2vec import sentence_vectorization
# from trapiche.baseData import load_taxonomy_sets

# %% ../nbs/01.2_knn_cosine_figure.ipynb 19
def get_species_from_diamond_set(taxo_set):
    """ function to extract the tax_annot as sp level in diamond
    """
    resu =  set()
    for x in taxo_set:
        spl = x.split()
        if len(spl)<2:continue
        resu.update({" ".join(x.split()[:2])})
    return resu

def process_get_average_embedd_macro_average_by_genus(set_of_species):
    """ function to calculate macro average vector at sp level, weighted by genus
    return dictionary with {genus:vector_of_sp_at_genus}
    """
    dct,mat = {},{}
    for i in set_of_species:
        dct.setdefault(i.split()[0],[]).append(i)
    
    for g,s in dct.items():
        cu = sentence_vectorization(s)
        mat[g] = cu
    return mat

def process_diamond(taxo_set):
    """ function to extract species and genus from diamon taxonomic annot
    """
    sp = get_species_from_diamond_set(taxo_set)
    gr = {x.split()[0] for x in sp}
    return sp,gr


# %% ../nbs/01.2_knn_cosine_figure.ipynb 20
def process_krona(taxo_set):
    """ function to extract species and genus from SSU/LLU taxonomic annot
    """
    sp = {" ".join(x.split('__')[-1].replace('_',' ').split()[:2]).replace('_',' ') for x in taxo_set if len( x.split('__')[-1].replace('_',' ').split() )>1}
    gr = {x.split('__')[-1] for x in taxo_set if 'g' == x.split('__')[0]}
    return sp,gr


# %% ../nbs/01.2_knn_cosine_figure.ipynb 21
def extract_taxo(taxo_set,file):
    """Wrapper to extract taxo from diamond or krona given a set of taxonomic annotations
    """
    if 'diamond' in file:
        sp,gr = process_diamond(taxo_set)
    else:
        sp,gr = process_krona(taxo_set)
    return sp,gr

# %% ../nbs/01.2_knn_cosine_figure.ipynb 25
def calculate_mean_gr_vec(p,gr):
    """ fuinction to calculate the mean of a set of gr
    """
    vec = sentence_vectorization(gr)
    return vec
    
def calculate_gr_macro_vec(sp,gr):
    """ fuinction to calculate the mean of a set . genus macro av
    """
    sp_mat = process_get_average_embedd_macro_average_by_genus(sp)
    
    mis_gr = gr-set(sp_mat)
    mean2 = sentence_vectorization(mis_gr)

    try:
        mean1 = np.mean(np.vstack([x for x in sp_mat.values() if x.dtype=='float32']),axis=0)
    except:
        mean1=mean2

    n1 = len(sp_mat)
    n2 = len(mis_gr)
    
    sp_mean = (n1 / (n1 + n2)) * mean1 + (n2 / (n1 + n2)) * mean2

    return sp_mean
    
def calculate_gr_plus_sp_vec(sp,gr):
    """ fuinction to calculate the mean of a set of gr_sp stack
    """
    # sp_mat = process_get_average_embedd_macro_average_by_genus(sp)
    mean_sp =calculate_gr_macro_vec(sp,gr)
    mean_gr = sentence_vectorization(gr)
    
    # try:
        # mean_sp = np.mean(np.vstack([x for x in sp_mat.values() if x.dtype=='float32']),axis=0)
    # except:
        # mean_sp=mean_gr
    mean = np.hstack([mean_sp,mean_gr])
    
    return mean


# %% ../nbs/01.2_knn_cosine_figure.ipynb 26
vec_size = sentence_vectorization(['root']).shape[0]

# %% ../nbs/01.2_knn_cosine_figure.ipynb 30
# list(biome_original_graph.nodes)
# list of biomes that make biological sense
min_annots = {
    'root:Engineered:Biogas plant',
    'root:Engineered:Bioreactor',
    'root:Engineered:Food production',
    'root:Engineered:Solid waste',
    'root:Engineered:Wastewater',
    'root:Environmental:Air',
    'root:Host-associated:Algae',
    'root:Host-associated:Cnidaria',
    'root:Host-associated:Echinodermata',
    'root:Host-associated:Fungi',
    'root:Host-associated:Porifera',
    'root:Environmental:Aquatic:Aquaculture',
    'root:Environmental:Aquatic:Estuary',
    'root:Environmental:Aquatic:Freshwater',
    'root:Environmental:Aquatic:Lentic',
    'root:Environmental:Aquatic:Marine',
    'root:Environmental:Aquatic:Meromictic lake',
    'root:Environmental:Aquatic:Non-marine Saline and Alkaline',
    'root:Environmental:Aquatic:Sediment',
    'root:Environmental:Aquatic:Thermal springs',
    'root:Environmental:Terrestrial:Agricultural field',
    'root:Environmental:Terrestrial:Asphalt lakes',
    'root:Environmental:Terrestrial:Deep subsurface',
    'root:Environmental:Terrestrial:Geologic',
    'root:Environmental:Terrestrial:Oil reservoir',
    'root:Environmental:Terrestrial:Rock-dwelling (subaerial biofilm)',
    'root:Environmental:Terrestrial:Soil',
    'root:Environmental:Terrestrial:Volcanic',
    'root:Host-associated:Amphibia:Digestive system',
    'root:Host-associated:Amphibia:Excretory system',
    'root:Host-associated:Animal:Circulatory system',
    'root:Host-associated:Animal:Digestive system',
    'root:Host-associated:Animal:Fossil',
    'root:Host-associated:Animal:Reproductive system',
    'root:Host-associated:Animal:Respiratory system',
    'root:Host-associated:Animal:Skin',
    'root:Host-associated:Annelida:Digestive system',
    'root:Host-associated:Annelida:Integument',
    'root:Host-associated:Annelida:Intracellular endosymbionts',
    'root:Host-associated:Annelida:Reproductive system',
    'root:Host-associated:Arthropoda:Digestive system',
    'root:Host-associated:Arthropoda:Integument',
    'root:Host-associated:Arthropoda:Intracellular endosymbionts',
    'root:Host-associated:Arthropoda:Oral cavity',
    'root:Host-associated:Arthropoda:Respiratory system',
    'root:Host-associated:Arthropoda:Symbiotic fungal gardens and galleries',
    'root:Host-associated:Arthropoda:Venom gland',
    'root:Host-associated:Birds:Circulatory system',
    'root:Host-associated:Birds:Digestive system',
    'root:Host-associated:Birds:Reproductive system',
    'root:Host-associated:Birds:Respiratory system',
    'root:Host-associated:Fish:Circulatory system',
    'root:Host-associated:Fish:Digestive system',
    'root:Host-associated:Fish:Excretory system',
    'root:Host-associated:Fish:Reproductive system',
    'root:Host-associated:Fish:Skin',
    'root:Host-associated:Human:Circulatory system',
    'root:Host-associated:Human:Digestive system',
    'root:Host-associated:Human:Excretory system',
    'root:Host-associated:Human:Fossil',
    'root:Host-associated:Human:Lympathic system',
    'root:Host-associated:Human:Milk',
    'root:Host-associated:Human:Nervous system',
    'root:Host-associated:Human:Reproductive system',
    'root:Host-associated:Human:Respiratory system',
    'root:Host-associated:Human:Skin',
    'root:Host-associated:Insecta:Digestive system',
    'root:Host-associated:Invertebrates:Bryozoans',
    'root:Host-associated:Invertebrates:Cnidaria',
    'root:Host-associated:Invertebrates:Echinodermata',
    'root:Host-associated:Mammals:Circulatory system',
    'root:Host-associated:Mammals:Digestive system',
    'root:Host-associated:Mammals:Excretory system',
    'root:Host-associated:Mammals:Gastrointestinal tract',
    'root:Host-associated:Mammals:Lymphatic',
    'root:Host-associated:Mammals:Milk',
    'root:Host-associated:Mammals:Nervous system',
    'root:Host-associated:Mammals:Reproductive system',
    'root:Host-associated:Mammals:Respiratory system',
    'root:Host-associated:Mammals:Skin',
    'root:Host-associated:Microbial:Bacteria',
    'root:Host-associated:Microbial:Dinoflagellates',
    'root:Host-associated:Mollusca:Digestive system',
    'root:Host-associated:Mollusca:Respiratory system',
    'root:Host-associated:Mollusca:Shell',
    'root:Host-associated:Plants:Phylloplane',
    'root:Host-associated:Plants:Rhizome',
    'root:Host-associated:Plants:Rhizoplane',
    'root:Host-associated:Plants:Rhizosphere',
    'root:Host-associated:Plants:Root',
    'root:Host-associated:Reptile:Oral cavity',
    'root:Host-associated:Tunicates:Ascidians',
}

# %% ../nbs/01.2_knn_cosine_figure.ipynb 37
""" PARAMS
"""
k =100
min_projects_vote=3  # minimum of projects votes for consideration

dominance_thres=0.5#67 # biomes with at least this fraction in the top k will be considered
k2=33
dominance_thres2=0.5 # biomes with at least this fraction in the top k will be considered

# %% ../nbs/01.2_knn_cosine_figure.ipynb 40
core_df_file = f"{DATA_DIR}/core_df.tsv"
genus_plus_sp_vec_file = f"{TMP_DIR}/genus_plus_sp_vec.npy"
genus_vec_file = f"{TMP_DIR}/genus_vec.npy"

# %% ../nbs/01.2_knn_cosine_figure.ipynb 42
def load_core_data():
    core_df = pd.read_csv(core_df_file,sep='\t')
    genus_plus_sp_vec = np.load(genus_plus_sp_vec_file)
    genus_vec = np.load(genus_vec_file)
    return core_df,genus_vec,genus_plus_sp_vec
    # return core_df,genus_vec

# %% ../nbs/01.2_knn_cosine_figure.ipynb 43
core_df,genus_vec,genus_plus_sp_vec = load_core_data()
# core_df,genus_vec = load_core_data()

# %% ../nbs/01.2_knn_cosine_figure.ipynb 86
from .goldOntologyAmendments import biome_herarchy_dct

# %% ../nbs/01.2_knn_cosine_figure.ipynb 258
def get_nodes_frquencies(co):
    """ Calculate fuzzy array for each sample
    The idea is that each node in the BIOME_AMEND space is a fuzzy category that can be calculated via the frequency of the node in the lineage of the KNN samples:
    """
    """ Function to calculate the requency of each node in the lineages of the knn samples
    """
    total_samples = co.sum()
    _node_frquencies = {}
    for lineage,count in co.items():
        for node in lineage.split(':'):
            _node_frquencies.setdefault(node,[]).append(count)
    node_frequencies = {k:sum(v)/total_samples for k,v in _node_frquencies.items()}
    return node_frequencies

# %% ../nbs/01.2_knn_cosine_figure.ipynb 269
BIOME_AMEND_ABUNDANCE = {x:{xx:1. for xx in x.split(":")} for x in list(biome_herarchy_dct.values())}
nodes_list = sorted({n for l in core_df.BIOME_AMEND.unique() for n in l.split(':')[1:]})

def weighted_jaccard(dict1, dict2):
    """ cate weighted jaccars similarity
    """
    # Calculate the numerator: sum of minimum values for shared keys
    min_sum = sum([min(dict1[species], dict2[species]) for species in set(dict1) & set(dict2)])
    
    # Calculate the denominator: sum of maximum values for all keys
    max_sum = sum([max(dict1.get(species, 0), dict2.get(species, 0)) for species in set(dict1) | set(dict2)])
    
    return min_sum / max_sum if max_sum != 0 else 0
    
def get_best_shot(_selection,func,restriction=''):
    """ Function tio calculate which is the best matching lineage based on weighted jaccard of fuzzy tags
    """
    js = {k:func(_selection, abund) for k,abund in BIOME_AMEND_ABUNDANCE.items() if restriction in k}
    so = sorted(js.items(),key=lambda x:-x[1])
    return so[:3]

# %% ../nbs/01.2_knn_cosine_figure.ipynb 271
fuzzy_mat_file = f"{TMP_DIR}/fuzzy_mat_file.npy"

# %% ../nbs/01.2_knn_cosine_figure.ipynb 291
fuzzy_mat_amend_file = f"{DATA_DIR}/fuzzy_mat_amend_file.npy"

# %% ../nbs/01.2_knn_cosine_figure.ipynb 293
fuzzy_mat_amend = np.load(fuzzy_mat_amend_file)

# %% ../nbs/01.2_knn_cosine_figure.ipynb 320
amended_core_df_file = f"{DATA_DIR}/amended_core_df.tsv"
amended_core_df_file

# %% ../nbs/01.2_knn_cosine_figure.ipynb 324
amended_core_df_slim = pd.read_csv(amended_core_df_file,sep='\t')

# %% ../nbs/01.2_knn_cosine_figure.ipynb 326
import sys
import json
import numpy as np
import pandas as pd
from ssfMiscUtilities.generic import split_list
from .utils import cosine_similarity_pairwise
from .baseData import tax_annotations_from_file
import networkx as nx
from .goldOntologyAmendments import biome_graph

# %% ../nbs/01.2_knn_cosine_figure.ipynb 327
np.seterr(divide='ignore', invalid='ignore')  # handle bad files == divition by zero error

# %% ../nbs/01.2_knn_cosine_figure.ipynb 328
k_nn=100 # k nearest neighbours to vote
tails = int(k_nn/4)+1

def get_top_k(arg_sort_sim,limit=1000):
    
    tmp = amended_core_df_slim.loc[arg_sort_sim[-limit:]].groupby('STUDY_ID', group_keys=False).apply(lambda x: x.tail(tails))
    nored = [x for x in arg_sort_sim[-limit:] if x in tmp.index]
    screening = tmp.loc[nored].iloc[-k_nn:]
    fuzzy_sum = np.sum(fuzzy_mat_amend[screening.index], axis=0)/len(screening)
    fuzzy_sum[(fuzzy_sum > .5)&(fuzzy_sum<.95)] = .95
    _selection = {nodes_list[x]: fuzzy_sum[x] for x in np.where(fuzzy_sum>0)[0]}
    prediction,w_jacc = get_best_shot(_selection,weighted_jaccard)[0]

    return prediction,w_jacc

# %% ../nbs/01.2_knn_cosine_figure.ipynb 329
def fuzzy_prediction(query_vector):
    """ Function to use fuzzy tags for prediction of biome based on taxonomic compositon
    """
    # calculate cosine similarity
    sims = cosine_similarity_pairwise(query_vector,genus_vec)
    sims[np.isnan(sims)] = 0
    argsort_sims = np.argsort(sims)

    results = []

    for ix in range(argsort_sims.shape[0]):
        arg_sort_sim = argsort_sims[ix,:]
        prediction,w_jacc = get_top_k(arg_sort_sim)
        results.append((prediction,w_jacc))
    return results

# %% ../nbs/01.2_knn_cosine_figure.ipynb 330
def chunked_fuzzy_prediction(query_vector,chunk_size=200):
    """ wrapper to process prediction in chunks
    """

    N_CHUNKS = int(math.ceil(query_vector.shape[0]/chunk_size))

    splits = split_list(list(range(query_vector.shape[0])),N_CHUNKS)

    results = []

    for spl in splits:
        _results = fuzzy_prediction(query_vector[spl])
        results.extend(_results)
    return results
        

# %% ../nbs/01.2_knn_cosine_figure.ipynb 331
def vectorise_run(list_of_tax_files):
    """ function to predicrize a run based on multiple taxonomy files. e.g. diamond +LSU+SSU, or SSU+LSU
    """
    taxo_sets = {f:tax_annotations_from_file(f) for f in list_of_tax_files}
    tax_tags = {'sp':set(),'gr':set()}
    for f,taxos in taxo_sets.items():
        sp,gr = extract_taxo(taxos,f)
        tax_tags['sp'].update(sp)
        tax_tags['gr'].update(gr)

    vec = sentence_vectorization(tax_tags['gr'])
    return vec



# %% ../nbs/01.2_knn_cosine_figure.ipynb 332
def predict_runs(
    list_of_list # list where each element represents a run, with multiple files from taxonomy annotation
                ):
    """ function to predict lineage of runs, based on multiple taxonomy files. e.g. diamond +LSU+SSU, or SSU+LSU. TAKE FILE WITH TXT FORMAT e.g DRR244685_MERGED_FASTQ_SSU.fasta.mseq.txt
    """


    full_vec= np.zeros((len(list_of_list),vec_size))

    for ix,li in enumerate(list_of_list):
        full_vec[ix] = vectorise_run(li)

    result = chunked_fuzzy_prediction(full_vec)
    return result

